// Copyright (c) 2017, 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
:projectid: docker
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-description: Learn how to use Docker containers for iterative development. 
:page-releasedate: 2017-12-27
:page-tags: ['Docker']
:page-related-guides: ['rest-intro']
:page-guide-category: basic
:page-essential: true
:page-essential-order: 4
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Learn how to use Docker containers for iterative development 
:page-seo-description: A getting started tutorial with examples of how to run a simple RESTful Java microservice in a Docker container built from a Dockerfile.
:guide-author: Open Liberty
= Using Docker containers to develop microservices

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use Docker containers for iterative development.

:linux: LINUX
:win: WINDOWS
:mac: MAC

// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

You will learn how to set up, run, and iteratively develop a simple REST application in a container with Open Liberty and Docker.

The implementation of the REST application can be found in the
`start/src` directory. To learn more about this application and how to build it, read
https://openliberty.io/guides/rest-intro.html[Creating a RESTful web service^].

To iteratively develop your application in a container, you can use development mode, which will automatically
build a Docker image, mount the required directories, bind the required ports, and run the application inside of a container. 
Development mode will also listen for any changes and rebuild the image and restart the container as nessecary. 

=== What is Docker?

Docker is a tool that you can use to deploy and run applications with containers. You
can think of Docker like a virtual machine that runs various applications. However, unlike a typical virtual
machine, you can run these applications simultaneously on a single system and independent of
one another.

Learn more about Docker on the https://www.docker.com/what-docker[official Docker website^].

To install Docker, follow the instructions in the https://docs.docker.com/engine/installation[official Docker documentation^].

=== What is a container?

A container is a lightweight, stand-alone package that contains a piece of software that is bundled together
with the entire environment that it needs to run. Containers are small compared to regular images and can
run on any environment where Docker is set up. Moreover, you can run multiple containers on a single
machine at the same time in isolation from each other.

Learn more about containers on the https://www.docker.com/what-container[official Docker website^].

=== Why use containers?

Consider a scenario where you need to deploy your application on another environment. Your application
works on your local machine, but when you try to run it on a different environment, it breaks. You do
some debugging and discover that you built your application with Java 8,
but this new environment has only Java 11 installed. Although this issue is generally easy to fix,
you don't want your application to be missing dozens of version-specific dependencies.
You can create a virtual machine specifically for testing your application, but VM images generally
take up a huge amount of space and are slow to run.

To solve the problem, you can containerize your application by
bundling it together with the entire environment that it needs to run. You can then run this container
on any machine that is running Docker regardless of how that machine's environment is set up. You can also run multiple
containers on a single machine in isolation from one another so that two containers that have different
versions of Java do not interfere with each other. Containers are quick to run compared to individual VMs,
and they take up only a fraction of the memory of a single virtual machine image.

// =================================================================================================
// Getting Started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Running the container 
// =================================================================================================

== Running the container 

The Open Liberty Maven plug-in includes a `devc` goal, known as "development mode with a container" that builds a Docker image, mounts the required directories,
binds the required ports, and then runs the application inside of a container. This development mode will also listen for any 
changes in the application source code or configuration and will rebuild the image and/or restart the container as nessecary.
If a Dockerfile is present, development mode will use it to build the image and container, otherwise the default Open Liberty image, 
`openliberty/open-liberty:kernel-java8-openj9-ubi`, will be used.


Build and run the container by running the `devc` goal from the `start` directory

[role='command']
```
mvn liberty:devc
```

Because there is no Dockerfile present in this directory, the default Open Liberty image is being used.  

Before you access your application from the browser, run the `docker ps` command from the command line to make sure that your
container is running and didn’t crash:

[role='command']
```
docker ps 
```

You should see something similar to the following output:

[role="no_copy"]
----
CONTAINER ID        IMAGE               CREATED             STATUS              NAMES
6493c5704c34        dev-mode-image      16 seconds ago      Up 15 seconds       "/opt/ol/helpers/run…" 
----


To view a full list of all available containers, run the `docker ps -a` command from the command line.

If your container is running without problems, point your browser to http://localhost:9080/LibertyProject/System/properties[http://localhost:9080/LibertyProject/System/properties^] 
where you can see a JSON file that contains the system properties of the JVM in your container.

// =================================================================================================
// Updating the application while the container is running 
// =================================================================================================

== Updating the application while the container is running

// File 0 
PropertiesResource.java
[source, java, linenums, role='code_column hide_tags=comment']
----
include::finish/src/main/java/io/openliberty/guides/rest/PropertiesResource.java[]
----

With your container running, make the following update to the source code.

[role="code_command hotspot hotspot file=0", subs="quotes"]
----
#Update the `PropertiesResource` class.#
`src/main/java/io/openliberty/guides/rest/PropertiesResource.java`
----

[role="edit_command_text"]
Change the endpoint of your application from `properties` to `properties-new` by changing the [hotspot=Path]`@Path`
annotation to `"properties-new"`.

After you make the file changes, Open Liberty automatically restarts the container. To see these changes reflected in the application, 
point your browser to http://localhost:9080/LibertyProject/System/properties-new[http://localhost:9080/LibertyProject/System/properties-new^].

When you need to stop the container, press `CTRL+C` in the session that the container was started in or run 
the `mvn liberty:stop` goal from the `start` directory in another shell session. This will both stop and 
remove the container for you. You can check that the container was stopped by  running the `docker ps` 
command again.

[role='command']
```
mvn liberty:stop
```

// =================================================================================================
// Creating the Dockerfile
// =================================================================================================

== Creating the Dockerfile

// File 0
Dockerfile
[source, text, linenums, role="code_column"]
----
include::finish/Dockerfile[]
----

// File 1
`.dockerignore`
[source, text, linenums, role="code_column"]
----
include::finish/.dockerignore[]
----

As mentioned previously, development mode with a container can be used with or without a Dockerfile. 
A Dockerfile is a collection of instructions for building a Docker image that can then be run as a
container. Every Dockerfile begins with a parent or base image on top of which various commands
are run. For example, you can start your image from scratch and execute commands that download and
install Java, or you can start from an image that already contains a Java installation.

Let's try running development mode with a Dockerfile. Navigate to the `start` directory to begin.

[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Dockerfile`.#
`Dockerfile`
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your
image is built. If you don't need a parent image, then use `FROM scratch`, which makes your image a
base image. 

In this case, you’re using the `openliberty/open-liberty:kernel-java8-openj9-ubi` image as your parent image, 
which comes with the latest Open Liberty runtime.

The [hotspot=link file=0]`RUN` instruction executes various shell commands in a new layer on top of the current image.
In this case, you create a symlink between the `/opt/ol/wlp/usr/servers` directory and the `/servers`
directory. This way, you can mount your servers more easily because you don't need to use long path names.
Note that since the Open Liberty Docker image runs by default with user `1001` (which is a non-root user),
you must temporarily switch to the `root` user to create the symlink. This is done by using 
the [hotspot=user-root hotspot=user file=0]`USER` instruction. 

Run the following command to inspect the [hotspot=description file=0]`descripton` field of the [hotspot=label file=0]`LABEL` that you specified in the Dockerfile 

[role='command']
```
docker inspect --format='{{.Config.Labels.description}}' dev-mode-image
```

As you can see, the Dockerfile you created is being used to run the container. 

=== Optional: Writing a .dockerignore file

When Docker runs a build, it sends all of the files and directories that are located in the same directory
as the Dockerfile to its build context, making them available for use in instructions like `ADD` and `COPY`.
To make image building faster, add all files and directories that aren't necessary for building your
image to a `.dockerignore` file. This excludes them from the build context.

A [hotspot file=1]`.dockerignore` file is available to you in the `start` directory. This file includes the [hotspot=src file=1]`src`
directory, the [hotspot=pom.xml file=1]`pom.xml` file, and some system files. Feel free to add anything else that you want to exclude.

// =================================================================================================
// Starting development mode with run options 
// =================================================================================================

== Starting development mode with run options

Another useful feature of development mode with a container is the ability to pass addtional options
to the `docker run` command. This can be done using the `-DdockerRunOpts` option with the `devc` goal.
Any options that you would normally add to the `docker run` command, can be added to this option. Here
is an example of an environment variable being passed in:

[role="no_copy"]
----
mvn liberty:devc -DdockerRunOpts="--env JAVA_HOME=/opt/java/openjdk"
----

If the Dockerfile isn't located in the directory that the `devc` goal is being run from, you can also 
use the `-Ddockerfile` option to specify the location. 

Additionally, both of these options can be added to the `pom.xml` file as under the `<configuration>` 
tag of the Liberty Maven Plugin as such:

[role="no_copy"]
----
<groupId>io.openliberty.tools</groupId>
<artifactId>liberty-maven-plugin</artifactId>
<version>3.2.2</version>
<configuration>
    <dockerRunOpts> ... </dockerRunOpts>
    <dockerFile> ... </dockerFile>
</configuration>
----

// =================================================================================================
// Testing the container 
// =================================================================================================

== Testing the container 

// File 0
EndpointIT.java
[source, java, linenums, role='code_column hide_tags=comment']
----
include::finish/src/test/java/it/io/openliberty/guides/rest/EndpointIT.java[]
----

You can test this service manually by starting a server and pointing a web browser to the 
http://localhost:9080/LibertyProject/System/properties-new[http://localhost:9080/LibertyProject/System/properties-new^] URL. 
Automated tests are a much better approach because they trigger a failure if a change introduces a bug.
JUnit and the JAX-RS Client API provide a simple environment to test the application. 
You can write tests for the individual units of code outside of a running application server, or they
can be written to call the application server directly. In this example, you will create a test that does the latter.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `EndpointIT` class.#
`src/test/java/it/io/openliberty/guides/rest/EndpointIT.java`
----

[role='command']
include::{common-includes}/devmode-test.adoc[]

You will see the following output:

[source,role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.rest.EndpointIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.884 sec - in it.io.openliberty.guides.rest.EndpointIT

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

When you are finished, press `CTRL+C` in the session that the container was started from. This will both stop and remove the container for you. 
You can check that the container was stopped by running the `docker ps` command.
